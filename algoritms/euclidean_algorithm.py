
def gcd_of_strings(self, str1: str, str2: str) -> str:
    # Напишите здесь свой код
    if str1 + str2 != str2 + str1:
        return ""

    dividend = len(str1)  # 30
    devisor = len(str2)  # 18

    # todo Алгоритм Евклида
    while devisor != 0:
        common_division = devisor
        devisor = dividend % devisor  # 30 % 18 = 12, 18 % 12 = 6, 12 % 6 = 0
        dividend = common_division

    return str1[:common_division]



def missing_number(self, nums: list[int]) -> int:
    n = len(nums)

    total = n * (n + 1) // 2 # todo формула: сумма арифметической прогрессии
    nums_total = sum(nums)
    return total - nums_total
    # Напишите здесь свой код

def missing_number(self, nums: list[int]) -> int:
    """
    Пример работы XOR-алгоритма для поиска пропавшего числа в массиве.

    Массив:
        nums = [3, 0, 1]
    Диапазон чисел: 0..n, где n = 3

    Цель:
        Найти пропавшее число, используя побитовое XOR.

    Пошаговое объяснение:

    1️⃣ Перевод чисел в биты (3 бита достаточно):
        0 → 000
        1 → 001
        2 → 010
        3 → 011

    Начальное значение:
        missing = n = 3 → 011

    2️⃣ Первый проход (i=0, num=3):
        missing = missing ^ i ^ num
        missing = 011 ^ 000 ^ 011
        Побитовое вычисление:
            бит2: 0 ^ 0 ^ 0 = 0
            бит1: 1 ^ 0 ^ 1 = 0
            бит0: 1 ^ 0 ^ 1 = 0
        Результат: missing = 000 → 0

    3️⃣ Второй проход (i=1, num=0):
        missing = 000 ^ 001 ^ 000
        Побитовое вычисление:
            бит2: 0 ^ 0 ^ 0 = 0
            бит1: 0 ^ 0 ^ 0 = 0
            бит0: 0 ^ 1 ^ 0 = 1
        Результат: missing = 001 → 1

    4️⃣ Третий проход (i=2, num=1):
        missing = 001 ^ 010 ^ 001
        Побитовое вычисление:
            бит2: 0 ^ 0 ^ 0 = 0
            бит1: 0 ^ 1 ^ 0 = 1
            бит0: 1 ^ 0 ^ 1 = 0
        Результат: missing = 010 → 2

    Вывод:
        После всех проходов missing = 010 (в десятичной 2)
        Это и есть пропавшее число.

    Ключевые свойства XOR, использованные здесь:
        - a ^ a = 0 (число XOR с самим собой обнуляется)
        - a ^ 0 = a (нулевой бит ничего не меняет)
        - XOR коммутативен и ассоциативен:
            порядок операций не важен.
        - Работает побитово для каждого бита числа.

    Особенности:
        - Массив может быть не упорядочен, алгоритм всё равно работает.
        - Пропавшее число может быть любым, включая первое (0) или последнее (n).
        - Алгоритм работает за один проход по массиву O(n) и использует O(1) памяти.
    """
    missing = len(nums)

    # todo Поиск пропавшего числа через XOR
    for index, num in enumerate(nums):
        missing = missing ^ index ^ num

    return missing

